### 2020/08/04 207题：课程表 ###
题目描述：
```text
你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

示例 1:
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。

示例 2:
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/course-schedule
```
题目分析：
```text
仔细思考会发现，所谓先决条件就相当于一个有向箭头，如果1-->0,则说明完成0必须先完成1,可以理解为
想到达0位置，就必须先到达1位置。那么什么情况下不能完成所有课程的学习呢？可想而知，如果出现了这
种情况：a-->...-->b且 b-->...-->a，也就是或如果完成a必须先完成b且完成b必须先完成a,那么就不可
能完成所有课程。那么，用哪种数据结构进行解题呢？最明显的当然是用有向图了。也就是判断一个有向图
是否出现了环。
```

题解一，拓扑排序：
```text
以每个节点的入度为量度，如果入度为0,则将其加入到一个队列中，其他和这个被加入到队列中的节点相邻接
的节点的入度减1，循环此操作，如果有环，最后必定有节点没有被加入到队列中，那么被加入到队列中的节点
数就会少于课程数。所以只需要判断被加入到队列中的节点数是否等于课程数。
```
python代码
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegrees = [0 for _ in range(numCourses)]
        # 使用邻接表保存有向图的信息
        adjacent = [[] for _ in range(numCourses)]
        from collections import deque
        queue = deque()
        added_to_queue = 0
        for cur, pre in prerequisites:
            indegrees[cur] += 1
            adjacent[pre].append(cur)
        for i in range(numCourses):
            if not indegrees[i]:
                queue.append(i)
                added_to_queue+=1
        while queue:
            node = queue.popleft()
            for j in adjacent[node]:
                indegrees[j] -= 1
                if not indegrees[j]:
                    queue.append(j)
                    added_to_queue+=1
        return numCourses == added_to_queue
```
java代码：
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegress = new int[numCourses*2];
        List<List<Integer>> adjacent = new ArrayList<>();
        int added_to_queue = 0;
        Queue<Integer> quequ = new LinkedList<>();
        List<Integer> out = new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            adjacent.add(new ArrayList<>());
        }
        for (int[] prerequisite : prerequisites) {
            indegress[prerequisite[0]]++;
            adjacent.get(prerequisite[1]).add(prerequisite[0]);
        }
        adjacent.add(out);
        for(int i=0;i<numCourses;i++){
            if(indegress[i]==0){
                quequ.add(i);
                added_to_queue++;
            }
        }
        while(quequ.size()!=0){
            int node = quequ.remove();
            for(int i = 0; i< adjacent.get(node).size(); i++){
                indegress[adjacent.get(node).get(i)]--;
                if(indegress[adjacent.get(node).get(i)]==0){
                    quequ.add(adjacent.get(node).get(i));
                    added_to_queue++;
                }
            }
        }
        return added_to_queue==numCourses;
    }
}
```
复杂度分析：
```text
时间复杂度O(N+M):遍历所有边N和节点M
空间复杂度O(N+M):为建立邻接表所花费的空间，邻接表长度为N,节点数为M
```